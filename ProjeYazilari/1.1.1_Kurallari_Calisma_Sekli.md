#!/usr/bin/env bash
# CIS 1.1.1.1 Audit - cramfs modülünün devre dışı olup olmadığını kontrol et

mod_name="cramfs"                           # Kontrol edilecek kernel modülü
conf_dir="/etc/modprobe.d"                  # Modül ayar dosyalarının dizini
conf_file="${conf_dir}/cramfs.conf"         # Özel ayar dosyası
kernel_ver="$(uname -r)"                    # Çalışan kernel versiyonu

# Exit kodları - otomasyonda kullanılmak üzere
# 0 = BAŞARILI (sistem güvenli)
# 1 = BAŞARISIZ (güvenlik açığı var)
# 2 = GEÇERLİ DEĞİL (bu kural bu sistem için uygulanamaz)

audit_result=0  # Başlangıç durumu: BAŞARILI


Adım 1: Modül Kernele gömülmüş mi kontrol et

if grep -qw "${mod_name}" "/lib/modules/${kernel_ver}/modules.builtin" 2>/dev/null; then
    echo "[INFO] ${mod_name} is built into the kernel - no action needed"
    exit 2  # Not applicable
fi
 - grep -qw : Sessiz mod -q ve tam kelime eşlemesi -w
 - modules.builtin : Kernel'a doğrudan derlenmiş modüllerin listesi
 - Neden exit 2 : Gömülü moduller zaten kernelin parçası, devere dışı bırakılamaz. Bu sistemde bu kural uygulanamaz.

 Adım 2: Modül dosyası sistemde var mı kontrol et

if ! find "/lib/modules/${kernel_ver}" -type f -name "${mod_name}.ko*" 2>/dev/null | grep -q .; then
    echo "[INFO] ${mod_name} module not found on system"
    exit 2  # Not applicable
fi

- find : Dosya arama komutu
- /lib/modules/${kernel_ver} : Kernel modüllerinin bulunduğu dizin
- -type f : Dosya tipi kontrolü
- -name "${mod_name}.ko*" : Dosya adı eşleme
- 2>/dev/null : Hata mesajlarını gizle
- grep -q . : Eşleşme varsa sessiz şekilde
- Neden exit 2 : Modül dosyası bulunamazsa, bu sistemde bu kural uygulanamaz.  ! kullanılmasının sebebi  Mantıksal NOT

Adım 3: Modul şu anda yüklü mü kontrol et

if lsmod | grep -qw "^${mod_name}"; then
    echo "[FAIL] ${mod_name} module is currently loaded"
    audit_result=1
else
    echo "[PASS] ${mod_name} module is not loaded"
fi

- lsmod : Modül listeleme komutu
- grep -qw : Sessiz mod -q ve tam kelime eşlemesi -w
- ^${mod_name} : Modül adı başlangıcı
- Neden audit_result=1 : Modül yüklüyse güvenlik riski vari, ancak diğer kontrolleri de yapmamız gerekiyor.
- Neden else : Modül yüklü değilse başarılı remdediation'a gerek yok ancak diğer kontrolleri yapmamız gerekiyor.

Adım 4: Install directive kontrol et

if grep -Prq "^\s*install\s+${mod_name}\s+/(?:usr/)?bin/(?:true|false)\s*" "${conf_dir}/" 2>/dev/null; then
    echo "[PASS] install directive configured for ${mod_name}"
else
    echo "[FAIL] install directive not configured for ${mod_name}"
    audit_result=1
fi

- grep -Prq : Sessiz mod -q ve tam kelime eşleme -P
- ^\s*install : Install komutunun başlangıcı
- /(?:usr/)?bin/(?:true|false) : Doğru komut dosyası
- 2>/dev/null : Hata mesajlarını gizle
- Neden audit_result=1 : Install directive bulunamazsa güvenlik riski vari, ancak diğer kontrolleri de yapmamız gerekiyor.
- Neden else : Install directive bulunamazsa başarılı remdediation'a gerek yok ancak diğer kontrolleri yapmamız gerekiyor.

Adım 5: Blacklist kontrol et

if grep -Prq "^\s*blacklist\s+${mod_name}\s*" "${conf_dir}/" 2>/dev/null; then
    echo "[PASS] ${mod_name} is blacklisted"
else
    echo "[FAIL] ${mod_name} is not blacklisted"
    audit_result=1
fi

- grep -Prq : Sessiz mod -q ve tam kelime eşleme -P
- ^\s*blacklist : Blacklist komutunun başlangıcı
- /(?:usr/)?bin/(?:true|false) : Doğru komut dosyası. /bin/false veya /usr/bin/false her ikiside geçerli.
- 2>/dev/null : Hata mesajlarını gizle
- Neden audit_result=1 : Blacklist bulunamazsa güvenlik riski vari, ancak diğer kontrolleri de yapmamız gerekiyor.
- Neden else : Blacklist bulunamazsa başarılı remdediation'a gerek yok ancak diğer kontrolleri yapmamız gerekiyor.

Adım 6: Exit kodu kontrol et

exit $audit_result
# 0 = Tüm kontroller geçti, sistem güvenli
# 1 = En az bir kontrol başarısız, güvenlik açığı var
# 2 = Bu kural bu sistem için geçerli değil


Remediation Script Çalışma Mantığı

Adım 1: Ön kontroller (Audit ile Aynı)

# Eğer modül kernel'a gömülüyse, devre dışı bırakılamaz
if grep -qw "${mod_name}" "/lib/modules/${kernel_ver}/modules.builtin" 2>/dev/null; then
    echo "[SKIP] ${mod_name} kernel'a gömülü - devre dışı bırakılamaz"
    exit 0  # Hata değil, sadece uygulanamaz
fi

# Eğer modül sistemde yoksa, zaten güvenli
if ! find "/lib/modules/${kernel_ver}" -type f -name "${mod_name}.ko*" 2>/dev/null | grep -q .; then
    echo "[SKIP] ${mod_name} modülü sistemde yok"
    exit 0
fi

Adım 2: Dizin oluşturma

# modprobe.d dizini yoksa oluştur
if [[ ! -d "${conf_dir}" ]]; then
    mkdir -p "${conf_dir}"
    echo "[CREATED] ${conf_dir} dizini oluşturuldu"
fi

idempoint Nedir?
- Aynı scripti birden fazla çalışttırabilirsiniz
- Her seferinde aynı sonucu verir
- Mevcut yapılandırmayı bozmaz
- Hata vermez

Adım 3: Yapılandırma dosyası oluşturma

# Yapılandırma dosyasını oluştur veya üzerine yaz
{
    echo "# CIS 1.1.1.1 - Disable cramfs filesystem"
    echo "install ${mod_name} /bin/false"
    echo "blacklist ${mod_name}"
} > "${conf_file}"

echo "[CONFIGURED] ${conf_file} oluşturuldu/güncellendi"

- > "${conf_file}" : Yapılandırma dosyasını oluştur veya üzerine yaz(idempoint)
- { ***} : birden fazla echo'yu tek bir output stream'ye yaz
- Sonuç: /etc/modprobe.d/cramfs.conf dosyasına "install cramfs /bin/false" ve "blacklist cramfs" satırlarını ekler.

Oluşan dosya içeriği:
# CIS 1.1.1.1 - Disable cramfs filesystem
install cramfs /bin/false
blacklist cramfs

Adım 4: Modülü kaldırma

# Modülü kaldır
if lsmod | grep -qw "^${mod_name}"; then
    if modprobe -r "${mod_name}" 2>/dev/null; then
        echo "[UNLOADED] ${mod_name} modülü kaldırıldı"
    else
        echo "[WARNING] ${mod_name} modülü kaldırılamadı - yeniden başlatılmalıdır"
    fi
else
    echo "[OK] ${mod_name} modülü zaten kaldırılmış"
fi

- lsmod : Modül listeleme komutu
- grep -qw : Sessiz mod -q ve tam kelime eşleme -w
- ^${mod_name} : Modül adı başlangıcı
- modprobe -r : Modülü kaldır
- 2>/dev/null : Hata mesajlarını gizle
- Neden else : Modül kaldırılmışsa başarılı remdediation'a gerek yok ancak diğer kontrolleri yapmamız gerekiyor.

Neden başarısız olabilir?
- Modül kullanımda (mount edilmiş bir cramfs dosya sistemi var)
- Başka bir modül buna bağımlı
- Çözüm: Yeniden başlatmada yüklenemeyecek, kalıcı çözüm sağlandı

Adım 5: initramfs/initrd güncelleme

# initramfs/initrd güncelleme
if command -v update-initramfs >/dev/null 2>&1; then
    echo "[UPDATE] initramfs güncelleniyor..."
    update-initramfs -u -k all >/dev/null 2>&1 || true
elif command -v dracut >/dev/null 2>&1; then
    echo "[UPDATE] initramfs güncelleniyor..."
    dracut -f >/dev/null 2>&1 || true
fi

- update-initramfs : initramfs güncelleme komutu
- dracut : initramfs güncelleme komutu
- -u : initramfs güncelle
- -k all : tüm kernel versiyonları için güncelle
- 2>/dev/null : Hata mesajlarını gizle
- Neden else : initramfs güncellenemiyorsa hata vermez

Inıtramfs Nedir?
- initramfs : initramfs, initramfs (initial RAM filesystem) 
- Sistem boot sırasında kullanılan geçici dosya sistemi
- Kernel'ın boot sırasında modülleri yüklemek için kullanılır
- Bazı moduller burada yüklenebilir
- Neden günvelliyoruz? modprobe.d dosyasındaki kurallar initramfs/initrd içinde de geçerli olmalı

Dağıtım farkları
- update-initramfs : Debian/Ubuntu
- dracut : Red Hat/CentOS
- || true: Hata olsa bile devam et (kritik değil)

Adım 6: sonuç mesajı

echo "[SUCCESS] ${mod_name} modülü devre dışı bırakıldı"



