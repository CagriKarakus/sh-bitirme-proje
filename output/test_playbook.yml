---
# Custom CIS Benchmark Hardening Playbook
# Generated from 2 selected rules
#
# Rules: 1.5.1, 1.5.2

- name: Custom CIS Benchmark Hardening
  hosts: "{{ target_hosts | default('all') }}"
  become: true
  gather_facts: true

  vars:
    cis_apply_remediation: true
    cis_report_dir: /tmp/cis_custom_report

  pre_tasks:
    - name: Create report directory
      file:
        path: "{{ cis_report_dir }}"
        state: directory
        mode: "0755"

    - name: Display start message
      debug:
        msg: "Starting CIS hardening for 2 selected rules"

  tasks:

    # ===== Rule 1/2: 1.5.1 =====

    - name: "[1/2] Check 1.5.1: address space layout randomization is enabled"
      shell: |
        # 1.5.1 Ensure address space layout randomization is enabled (Automated)
        # Description: Address space layout randomization (ASLR) is an exploit mitigation 
        # technique which randomly arranges the address space of key data areas of a process.
        # Rationale: Randomly placing virtual memory regions will make it difficult to write 
        # memory page exploits as the memory placement will be consistently shifting.
        
        {
            a_output=(); a_output2=(); a_parlist=("kernel.randomize_va_space=2")
            l_ufwscf="$([ -f /etc/default/ufw ] && awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)"
            
            f_kernel_parameter_chk()
            {
                l_running_parameter_value="$(sysctl "$l_parameter_name" | awk -F= '{print $2}' | xargs)" # Check running configuration
                if grep -Pq -- '\b'"$l_parameter_value"'\b' <<< "$l_running_parameter_value"; then
                    a_output+=(" - \"$l_parameter_name\" is correctly set to \"$l_running_parameter_value\" in the running configuration")
                else
                    a_output2+=(" - \"$l_parameter_name\" is incorrectly set to \"$l_running_parameter_value\" in the running configuration and should have a value of: \"$l_value_out\"")
                fi
                
                unset A_out; declare -A A_out # Check durable setting (files)
                while read -r l_out; do
                    if [ -n "$l_out" ]; then
                        if [[ $l_out =~ ^\s*# ]]; then
                            l_file="${l_out//# /}"
                        else
                            l_kpar="$(awk -F= '{print $1}' <<< "$l_out" | xargs)"
                            [ "$l_kpar" = "$l_parameter_name" ] && A_out+=(["$l_kpar"]="$l_file")
                        fi
                    fi
                done < <("$l_systemdsysctl" --cat-config | grep -Po '^\h*([^#\n\r]+|#\h*\/[^#\n\r\h]+\.conf\b)')
                
                if [ -n "$l_ufwscf" ]; then # Account for systems with UFW (Not covered by systemd-sysctl --cat-config)
                    l_kpar="$(grep -Po "^\h*$l_parameter_name\b" "$l_ufwscf" | xargs)"
                    l_kpar="${l_kpar//\//.}"
                    [ "$l_kpar" = "$l_parameter_name" ] && A_out+=(["$l_kpar"]="$l_ufwscf")
                fi
                
                if (( ${#A_out[@]} > 0 )); then # Assess output from files and generate output
                    while IFS="=" read -r l_fkpname l_file_parameter_value; do
                        l_fkpname="${l_fkpname// /}"; l_file_parameter_value="${l_file_parameter_value// /}"
                        if grep -Pq -- '\b'"$l_parameter_value"'\b' <<< "$l_file_parameter_value"; then
                            a_output+=(" - \"$l_parameter_name\" is correctly set to \"$l_file_parameter_value\" in \"$(printf '%s' "${A_out[@]}")\"")
                        else
                            a_output2+=(" - \"$l_parameter_name\" is incorrectly set to \"$l_file_parameter_value\" in \"$(printf '%s' "${A_out[@]}")\" and should have a value of: \"$l_value_out\"")
                        fi
                    done < <(grep -Po -- "^\h*$l_parameter_name\h*=\h*\H+" "${A_out[@]}")
                else
                    a_output2+=(" - \"$l_parameter_name\" is not set in an included file" \
                        " ** Note: \"$l_parameter_name\" May be set in a file that's ignored by load procedure **")
                fi
            }
            
            l_systemdsysctl="$(readlink -f /lib/systemd/systemd-sysctl)"
            while IFS="=" read -r l_parameter_name l_parameter_value; do # Assess and check parameters
                l_parameter_name="${l_parameter_name// /}"; l_parameter_value="${l_parameter_value// /}"
                l_value_out="${l_parameter_value//-/ through }"; l_value_out="${l_value_out//|/ or }"
                l_value_out="$(tr -d '(){}' <<< "$l_value_out")"
                f_kernel_parameter_chk
            done < <(printf '%s\n' "${a_parlist[@]}")
            
            if [ "${#a_output2[@]}" -le 0 ]; then
                printf '%s\n' "" "- Audit Result:" " ** PASS **" "${a_output[@]}" ""
                exit 0
            else
                printf '%s\n' "" "- Audit Result:" " ** FAIL **" " - Reason(s) for audit failure:" "${a_output2[@]}"
                [ "${#a_output[@]}" -gt 0 ] && printf '%s\n' "" "- Correctly set:" "${a_output[@]}" ""
                exit 1
            fi
        }
      register: audit_1_5_1
      failed_when: false
      changed_when: false
      check_mode: false

    - name: "[1/2] Remediate 1.5.1: address space layout randomization is enabled"
      shell: |
        # 1.5.1 Ensure address space layout randomization is enabled (Automated)
        # Remediation: Set kernel.randomize_va_space = 2 in sysctl configuration
        # Description: ASLR is an exploit mitigation technique which randomly arranges 
        # the address space of key data areas of a process.
        SYSCTL_CONF="/etc/sysctl.d/60-kernel_sysctl.conf"
        PARAM_NAME="kernel.randomize_va_space"
        PARAM_VALUE="2"
        echo "Setting $PARAM_NAME = $PARAM_VALUE"
        # Check current running value
        echo "1. Current running configuration:"
        CURRENT_VALUE=$(sysctl -n "$PARAM_NAME" 2>/dev/null)
        echo "   $PARAM_NAME = $CURRENT_VALUE"
        # Set the parameter in configuration file
        echo "2. Setting durable configuration in $SYSCTL_CONF..."
        # Create the file if it doesn't exist, or update if it does
        if [ -f "$SYSCTL_CONF" ]; then
            # Check if the parameter already exists in the file
            if grep -q "^$PARAM_NAME" "$SYSCTL_CONF"; then
                # Update existing parameter
                sed -i "s/^$PARAM_NAME.*/$PARAM_NAME = $PARAM_VALUE/" "$SYSCTL_CONF"
                echo "   [OK] Updated existing parameter in $SYSCTL_CONF"
            else
                # Append the parameter
                printf "%s\n" "$PARAM_NAME = $PARAM_VALUE" >> "$SYSCTL_CONF"
                echo "   [OK] Added parameter to $SYSCTL_CONF"
            fi
        else
            # Create new file with the parameter
            printf "%s\n" "$PARAM_NAME = $PARAM_VALUE" >> "$SYSCTL_CONF"
            echo "   [OK] Created $SYSCTL_CONF with parameter"
        fi
        # Apply the setting to the running kernel
        echo "3. Applying to running kernel..."
        sysctl -w "$PARAM_NAME=$PARAM_VALUE"
        if [ $? -eq 0 ]; then
            echo "   [OK] Applied successfully"
        else
            echo "   [ERROR] Failed to apply kernel parameter"
            exit 1
        fi
        # Verify
        echo "4. Verification:"
        NEW_VALUE=$(sysctl -n "$PARAM_NAME" 2>/dev/null)
        echo "   $PARAM_NAME = $NEW_VALUE"
        if [ "$NEW_VALUE" = "$PARAM_VALUE" ]; then
            echo "[SUCCESS] ASLR is now enabled with value $PARAM_VALUE"
            exit 0
        else
            echo "[ERROR] Failed to set ASLR value"
            exit 1
        fi
      when: audit_1_5_1.rc != 0 and cis_apply_remediation | bool
      register: remediate_1_5_1

    - name: "[1/2] Display result for 1.5.1"
      debug:
        msg: |
          Rule 1.5.1: {{ "PASS" if audit_1_5_1.rc == 0 else "FAIL -> REMEDIATED" if remediate_1_5_1 is defined and remediate_1_5_1.changed else "FAIL" }}


    # ===== Rule 2/2: 1.5.2 =====

    - name: "[2/2] Check 1.5.2: CIS Benchmark 1.5.2 - Ensure ptrace_scope is restricted"
      shell: |
        # CIS Benchmark 1.5.2 - Ensure ptrace_scope is restricted (Automated)
        # Profile: Level 1 - Server, Level 1 - Workstation
        #
        # NOTE: Ubuntu ships with /etc/sysctl.d/10-ptrace.conf which sets
        # kernel.yama.ptrace_scope = 1 by default (already CIS compliant)
        
        audit_ptrace_scope() {
            local l_output=""
            local l_output2=""
            local l_parameter_name="kernel.yama.ptrace_scope"
            
            # Check running configuration
            local l_running_value
            l_running_value="$(sysctl -n "$l_parameter_name" 2>/dev/null)"
            
            if [ -z "$l_running_value" ]; then
                l_output2="$l_output2\n - Unable to read $l_parameter_name from running configuration (Yama LSM may not be enabled)"
            elif [[ "$l_running_value" =~ ^[123]$ ]]; then
                l_output="$l_output\n - \"$l_parameter_name\" is correctly set to \"$l_running_value\" in the running configuration"
            else
                l_output2="$l_output2\n - \"$l_parameter_name\" is incorrectly set to \"$l_running_value\" in the running configuration (should be 1, 2, or 3)"
            fi
            
            # Check durable settings in configuration files
            local l_file_found=false
            local l_file_value=""
            local l_config_file=""
            
            # Check /etc/sysctl.conf and /etc/sysctl.d/*.conf
            # Only match lines that are NOT commented out (no leading #)
            for l_file in /etc/sysctl.conf /etc/sysctl.d/*.conf; do
                if [ -f "$l_file" ]; then
                    # Extract only uncommented lines, get the last occurrence
                    local l_match
                    l_match="$(grep -E "^[^#]*$l_parameter_name\s*=" "$l_file" 2>/dev/null | tail -1)"
                    if [ -n "$l_match" ]; then
                        l_file_value="$(echo "$l_match" | awk -F= '{print $2}' | tr -d ' \t')"
                        if [ -n "$l_file_value" ]; then
                            l_file_found=true
                            l_config_file="$l_file"
                        fi
                    fi
                fi
            done
            
            # Check UFW sysctl file if exists
            if [ -f /etc/default/ufw ]; then
                local l_ufwscf
                l_ufwscf="$(awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw | tr -d '"')"
                if [ -n "$l_ufwscf" ] && [ -f "$l_ufwscf" ]; then
                    local l_match
                    l_match="$(grep -E "^[^#]*$l_parameter_name\s*=" "$l_ufwscf" 2>/dev/null | tail -1)"
                    if [ -n "$l_match" ]; then
                        local l_ufw_value
                        l_ufw_value="$(echo "$l_match" | awk -F= '{print $2}' | tr -d ' \t')"
                        if [ -n "$l_ufw_value" ]; then
                            l_file_found=true
                            l_file_value="$l_ufw_value"
                            l_config_file="$l_ufwscf"
                        fi
                    fi
                fi
            fi
            
            if [ "$l_file_found" = true ]; then
                if [[ "$l_file_value" =~ ^[123]$ ]]; then
                    l_output="$l_output\n - \"$l_parameter_name\" is correctly set to \"$l_file_value\" in \"$l_config_file\""
                else
                    l_output2="$l_output2\n - \"$l_parameter_name\" is incorrectly set to \"$l_file_value\" in \"$l_config_file\" (should be 1, 2, or 3)"
                fi
            else
                l_output2="$l_output2\n - \"$l_parameter_name\" is not set in any sysctl configuration file"
                l_output2="$l_output2\n   (Note: Check if the value is commented out or file is missing)"
            fi
            
            # Output results
            if [ -z "$l_output2" ]; then
                echo -e "\n- Audit Result: ** PASS **"
                echo -e "$l_output\n"
                return 0
            else
                echo -e "\n- Audit Result: ** FAIL **"
                echo -e " - Reason(s) for audit failure:"
                echo -e "$l_output2"
                if [ -n "$l_output" ]; then
                    echo -e "\n- Correctly set:"
                    echo -e "$l_output\n"
                fi
                return 1
            fi
        }
        
        audit_ptrace_scope
      register: audit_1_5_2
      failed_when: false
      changed_when: false
      check_mode: false

    - name: "[2/2] Remediate 1.5.2: CIS Benchmark 1.5.2 - Ensure ptrace_scope is restricted"
      shell: |
        # CIS Benchmark 1.5.2 - Ensure ptrace_scope is restricted (Automated)
        # Profile: Level 1 - Server, Level 1 - Workstation
        #
        # Remediation: Set kernel.yama.ptrace_scope to 1 (restricted ptrace)
        #
        # NOTE: Ubuntu ships with /etc/sysctl.d/10-ptrace.conf by default.
        # This script uses a dedicated file /etc/sysctl.d/60-ptrace_scope.conf
        # to ensure our setting takes precedence (higher number = loaded later)
        remediate_ptrace_scope() {
            local l_parameter_name="kernel.yama.ptrace_scope"
            local l_parameter_value="1"  # Using restricted mode (value 1) as default
            local l_sysctl_file="/etc/sysctl.d/60-ptrace_scope.conf"
            echo "Setting $l_parameter_name to $l_parameter_value..."
            # Create directory if it doesn't exist
            if [ ! -d "/etc/sysctl.d" ]; then
                mkdir -p /etc/sysctl.d
            fi
            # Comment out (not delete) any existing entries to preserve original config
            for l_file in /etc/sysctl.conf /etc/sysctl.d/*.conf; do
                if [ -f "$l_file" ] && [ "$l_file" != "$l_sysctl_file" ]; then
                    # Only modify if there's an uncommented entry
                    if grep -Eq "^[^#]*$l_parameter_name\s*=" "$l_file" 2>/dev/null; then
                        echo " - Commenting out existing entry in $l_file"
                        sed -i "s/^\([^#]*$l_parameter_name\s*=\)/# \1/" "$l_file"
                    fi
                fi
            done
            # Check and update UFW sysctl file if exists
            if [ -f /etc/default/ufw ]; then
                local l_ufwscf
                l_ufwscf="$(awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw | tr -d '"')"
                if [ -n "$l_ufwscf" ] && [ -f "$l_ufwscf" ]; then
                    if grep -Eq "^[^#]*$l_parameter_name\s*=" "$l_ufwscf" 2>/dev/null; then
                        echo " - Commenting out existing entry in $l_ufwscf"
                        sed -i "s/^\([^#]*$l_parameter_name\s*=\)/# \1/" "$l_ufwscf"
                    fi
                fi
            fi
            # Create or overwrite our dedicated configuration file
            echo " - Writing $l_parameter_name=$l_parameter_value to $l_sysctl_file"
            cat > "$l_sysctl_file" << EOF
        # CIS Benchmark 1.5.2 - Ensure ptrace_scope is restricted
        # Generated by remediation script on $(date)
        # Values: 1=restricted, 2=admin-only, 3=no attach (irreversible)
        $l_parameter_name=$l_parameter_value
        EOF
            # Set the active kernel parameter
            echo " - Applying to running kernel..."
            if sysctl -w "$l_parameter_name=$l_parameter_value" > /dev/null 2>&1; then
                echo " - Successfully set $l_parameter_name to $l_parameter_value in running configuration"
            else
                echo " - WARNING: Failed to set $l_parameter_name in running configuration"
                echo "   Yama LSM may not be enabled in the kernel"
                return 1
            fi
            echo "Remediation complete."
            echo "Configuration saved to: $l_sysctl_file"
            echo "Value meanings:"
            echo "  1 = Restricted ptrace (only descendants can be traced)"
            echo "  2 = Admin-only attach (requires CAP_SYS_PTRACE)"
            echo "  3 = No attach (ptrace completely disabled, irreversible until reboot)"
            echo "If a value of 2 or 3 is required by local site policy,"
            echo "edit $l_sysctl_file and run: sysctl -p $l_sysctl_file"
            return 0
        }
        remediate_ptrace_scope
      when: audit_1_5_2.rc != 0 and cis_apply_remediation | bool
      register: remediate_1_5_2

    - name: "[2/2] Display result for 1.5.2"
      debug:
        msg: |
          Rule 1.5.2: {{ "PASS" if audit_1_5_2.rc == 0 else "FAIL -> REMEDIATED" if remediate_1_5_2 is defined and remediate_1_5_2.changed else "FAIL" }}

  post_tasks:
    - name: Display completion message
      debug:
        msg: "CIS hardening completed for 2 rules"
