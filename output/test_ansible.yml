---
# Custom CIS Benchmark Hardening Playbook
# Generated from 3 selected rules
#
# Rules: 1.1.1.1, 1.1.1.2, 1.5.1

- name: Custom CIS Benchmark Hardening
  hosts: "{{ target_hosts | default('all') }}"
  become: true
  gather_facts: true

  vars:
    cis_apply_remediation: true
    cis_report_dir: /tmp/cis_custom_report

  pre_tasks:
    - name: Create report directory
      file:
        path: "{{ cis_report_dir }}"
        state: directory
        mode: "0755"

    - name: Display start message
      debug:
        msg: "Starting CIS hardening for 3 selected rules"

  tasks:

    # ===== Rule 1/3: 1.1.1.1 =====

    - name: "[1/3] Check 1.1.1.1: CIS 1.1.1.1 Audit - Ensure cramfs kernel module is not available"
      shell: |
        # CIS 1.1.1.1 Audit - Ensure cramfs kernel module is not available
        
        mod_name="cramfs"
        conf_dir="/etc/modprobe.d"
        conf_file="${conf_dir}/cramfs.conf"
        kernel_ver="$(uname -r)"
        
        # Exit codes for integration
        # 0 = PASS, 1 = FAIL, 2 = NOT_APPLICABLE
        
        audit_result=0
        
        # Check if module is built into the kernel
        if grep -qw "${mod_name}" "/lib/modules/${kernel_ver}/modules.builtin" 2>/dev/null; then
            echo "[INFO] ${mod_name} is built into the kernel - no action needed"
            exit 2  # Not applicable
        fi
        
        # Check if the module exists as a loadable module
        if ! find "/lib/modules/${kernel_ver}" -type f -name "${mod_name}.ko*" 2>/dev/null | grep -q .; then
            echo "[INFO] ${mod_name} module not found on system"
            exit 2  # Not applicable
        fi
        
        echo "[CHECK] Auditing ${mod_name} kernel module configuration..."
        
        # Check if module is currently loaded
        if lsmod | grep -qw "^${mod_name}"; then
            echo "[FAIL] ${mod_name} module is currently loaded"
            audit_result=1
        else
            echo "[PASS] ${mod_name} module is not loaded"
        fi
        
        # Check for install directive
        if grep -Prq "^\s*install\s+${mod_name}\s+/(?:usr/)?bin/(?:true|false)\s*" "${conf_dir}/" 2>/dev/null; then
            echo "[PASS] install directive configured for ${mod_name}"
        else
            echo "[FAIL] install directive not configured for ${mod_name}"
            audit_result=1
        fi
        
        # Check for blacklist entry
        if grep -Prq "^\s*blacklist\s+${mod_name}\s*" "${conf_dir}/" 2>/dev/null; then
            echo "[PASS] ${mod_name} is blacklisted"
        else
            echo "[FAIL] ${mod_name} is not blacklisted"
            audit_result=1
        fi
        
        exit $audit_result
      register: audit_1_1_1_1
      failed_when: false
      changed_when: false
      check_mode: false

    - name: "[1/3] Remediate 1.1.1.1: CIS 1.1.1.1 Audit - Ensure cramfs kernel module is not available"
      shell: |
        # CIS 1.1.1.1 Remediation - Disable cramfs kernel module
        mod_name="cramfs"
        rule_id="1.1.1.1"
        conf_dir="/etc/modprobe.d"
        conf_file="${conf_dir}/cis-${mod_name}.conf"
        kernel_ver="$(uname -r)"
        # Managed block markers
        BLOCK_START="# BEGIN CIS ${rule_id} - Managed by CIS remediation"
        BLOCK_END="# END CIS ${rule_id}"
        echo "[REMEDIATE] Disabling ${mod_name} kernel module..."
        # Check if module is built into the kernel
        if grep -qw "${mod_name}" "/lib/modules/${kernel_ver}/modules.builtin" 2>/dev/null; then
            echo "[SKIP] ${mod_name} is built into the kernel - cannot be disabled"
            exit 0
        fi
        # Check if the module exists
        if ! find "/lib/modules/${kernel_ver}" -type f -name "${mod_name}.ko*" 2>/dev/null | grep -q .; then
            echo "[SKIP] ${mod_name} module not found on system"
            exit 0
        fi
        # Create modprobe.d directory if it doesn't exist
        if [[ ! -d "${conf_dir}" ]]; then
            mkdir -p "${conf_dir}"
            echo "[CREATED] ${conf_dir} directory"
        fi
        # Function to update or add managed block
        update_managed_block() {
            local file="$1"
            local block_content="$2"
            if [[ -f "$file" ]]; then
                # Remove existing managed block if present
                if grep -q "^${BLOCK_START}" "$file"; then
                    sed -i "/^${BLOCK_START}/,/^${BLOCK_END}/d" "$file"
                    echo "[INFO] Removed existing managed block from ${file}"
                fi
            fi
            # Append new managed block
            {
                echo "${BLOCK_START}"
                echo "${block_content}"
                echo "${BLOCK_END}"
            } >> "$file"
        }
        # Content to add
        block_content="install ${mod_name} /bin/false
        blacklist ${mod_name}"
        # Update configuration file with managed block
        update_managed_block "${conf_file}" "${block_content}"
        echo "[CONFIGURED] ${conf_file} updated with managed block"
        # Unload module if currently loaded
        if lsmod | grep -qw "^${mod_name}"; then
            if modprobe -r "${mod_name}" 2>/dev/null; then
                echo "[UNLOADED] ${mod_name} module removed from kernel"
            else
                echo "[WARNING] Could not unload ${mod_name} - may be in use (will be disabled on reboot)"
            fi
        else
            echo "[OK] ${mod_name} module not currently loaded"
        fi
        # Update initramfs/initrd if available
        if command -v update-initramfs >/dev/null 2>&1; then
            echo "[UPDATE] Updating initramfs..."
            update-initramfs -u -k all >/dev/null 2>&1 || true
        elif command -v dracut >/dev/null 2>&1; then
            echo "[UPDATE] Updating initramfs with dracut..."
            dracut -f >/dev/null 2>&1 || true
        fi
        echo "[SUCCESS] ${mod_name} module has been disabled"
      when: audit_1_1_1_1.rc == 1 and cis_apply_remediation | bool
      register: remediate_1_1_1_1
      ignore_errors: true

    - name: "[1/3] Display result for 1.1.1.1"
      debug:
        msg: |
          Rule 1.1.1.1: {{ "PASS" if audit_1_1_1_1.rc == 0 else "N/A" if audit_1_1_1_1.rc == 2 else "FIXED" if remediate_1_1_1_1 is defined and remediate_1_1_1_1.changed else "FAIL" }}


    # ===== Rule 2/3: 1.1.1.2 =====

    - name: "[2/3] Check 1.1.1.2: CIS 1.1.1.2 Audit - Ensure freevxfs kernel module is not available"
      shell: |
        # CIS 1.1.1.2 Audit - Ensure freevxfs kernel module is not available
        
        mod_name="freevxfs"
        conf_dir="/etc/modprobe.d"
        conf_file="${conf_dir}/freevxfs.conf"
        kernel_ver="$(uname -r)"
        
        # Exit codes for integration
        # 0 = PASS, 1 = FAIL, 2 = NOT_APPLICABLE
        
        audit_result=0
        
        # Check if module is built into the kernel
        if grep -qw "${mod_name}" "/lib/modules/${kernel_ver}/modules.builtin" 2>/dev/null; then
            echo "[INFO] ${mod_name} is built into the kernel - no action needed"
            exit 2  # Not applicable
        fi
        
        # Check if the module exists as a loadable module
        if ! find "/lib/modules/${kernel_ver}" -type f -name "${mod_name}.ko*" 2>/dev/null | grep -q .; then
            echo "[INFO] ${mod_name} module not found on system"
            exit 2  # Not applicable
        fi
        
        echo "[CHECK] Auditing ${mod_name} kernel module configuration..."
        
        # Check if module is currently loaded
        if lsmod | grep -qw "^${mod_name}"; then
            echo "[FAIL] ${mod_name} module is currently loaded"
            audit_result=1
        else
            echo "[PASS] ${mod_name} module is not loaded"
        fi
        
        # Check for install directive
        if grep -Prq "^\s*install\s+${mod_name}\s+/(?:usr/)?bin/(?:true|false)\s*" "${conf_dir}/" 2>/dev/null; then
            echo "[PASS] install directive configured for ${mod_name}"
        else
            echo "[FAIL] install directive not configured for ${mod_name}"
            audit_result=1
        fi
        
        # Check for blacklist entry
        if grep -Prq "^\s*blacklist\s+${mod_name}\s*" "${conf_dir}/" 2>/dev/null; then
            echo "[PASS] ${mod_name} is blacklisted"
        else
            echo "[FAIL] ${mod_name} is not blacklisted"
            audit_result=1
        fi
        
        exit $audit_result
      register: audit_1_1_1_2
      failed_when: false
      changed_when: false
      check_mode: false

    - name: "[2/3] Remediate 1.1.1.2: CIS 1.1.1.2 Audit - Ensure freevxfs kernel module is not available"
      shell: |
        # CIS 1.1.1.2 Remediation - Disable freevxfs kernel module
        mod_name="freevxfs"
        rule_id="1.1.1.2"
        conf_dir="/etc/modprobe.d"
        conf_file="${conf_dir}/cis-${mod_name}.conf"
        kernel_ver="$(uname -r)"
        # Managed block markers
        BLOCK_START="# BEGIN CIS ${rule_id} - Managed by CIS remediation"
        BLOCK_END="# END CIS ${rule_id}"
        echo "[REMEDIATE] Disabling ${mod_name} kernel module..."
        # Check if module is built into the kernel
        if grep -qw "${mod_name}" "/lib/modules/${kernel_ver}/modules.builtin" 2>/dev/null; then
            echo "[SKIP] ${mod_name} is built into the kernel - cannot be disabled"
            exit 0
        fi
        # Check if the module exists
        if ! find "/lib/modules/${kernel_ver}" -type f -name "${mod_name}.ko*" 2>/dev/null | grep -q .; then
            echo "[SKIP] ${mod_name} module not found on system"
            exit 0
        fi
        # Create modprobe.d directory if it doesn't exist
        if [[ ! -d "${conf_dir}" ]]; then
            mkdir -p "${conf_dir}"
            echo "[CREATED] ${conf_dir} directory"
        fi
        # Function to update or add managed block
        update_managed_block() {
            local file="$1"
            local block_content="$2"
            if [[ -f "$file" ]]; then
                # Remove existing managed block if present
                if grep -q "^${BLOCK_START}" "$file"; then
                    sed -i "/^${BLOCK_START}/,/^${BLOCK_END}/d" "$file"
                    echo "[INFO] Removed existing managed block from ${file}"
                fi
            fi
            # Append new managed block
            {
                echo "${BLOCK_START}"
                echo "${block_content}"
                echo "${BLOCK_END}"
            } >> "$file"
        }
        # Content to add
        block_content="install ${mod_name} /bin/false
        blacklist ${mod_name}"
        # Update configuration file with managed block
        update_managed_block "${conf_file}" "${block_content}"
        echo "[CONFIGURED] ${conf_file} updated with managed block"
        # Unload module if currently loaded
        if lsmod | grep -qw "^${mod_name}"; then
            if modprobe -r "${mod_name}" 2>/dev/null; then
                echo "[UNLOADED] ${mod_name} module removed from kernel"
            else
                echo "[WARNING] Could not unload ${mod_name} - may be in use (will be disabled on reboot)"
            fi
        else
            echo "[OK] ${mod_name} module not currently loaded"
        fi
        # Update initramfs/initrd if available
        if command -v update-initramfs >/dev/null 2>&1; then
            echo "[UPDATE] Updating initramfs..."
            update-initramfs -u -k all >/dev/null 2>&1 || true
        elif command -v dracut >/dev/null 2>&1; then
            echo "[UPDATE] Updating initramfs with dracut..."
            dracut -f >/dev/null 2>&1 || true
        fi
        echo "[SUCCESS] ${mod_name} module has been disabled"
      when: audit_1_1_1_2.rc == 1 and cis_apply_remediation | bool
      register: remediate_1_1_1_2
      ignore_errors: true

    - name: "[2/3] Display result for 1.1.1.2"
      debug:
        msg: |
          Rule 1.1.1.2: {{ "PASS" if audit_1_1_1_2.rc == 0 else "N/A" if audit_1_1_1_2.rc == 2 else "FIXED" if remediate_1_1_1_2 is defined and remediate_1_1_1_2.changed else "FAIL" }}


    # ===== Rule 3/3: 1.5.1 =====

    - name: "[3/3] Check 1.5.1: address space layout randomization is enabled"
      shell: |
        # 1.5.1 Ensure address space layout randomization is enabled (Automated)
        # Description: Address space layout randomization (ASLR) is an exploit mitigation 
        # technique which randomly arranges the address space of key data areas of a process.
        # Rationale: Randomly placing virtual memory regions will make it difficult to write 
        # memory page exploits as the memory placement will be consistently shifting.
        
        {
            a_output=(); a_output2=(); a_parlist=("kernel.randomize_va_space=2")
            l_ufwscf="$([ -f /etc/default/ufw ] && awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)"
            
            f_kernel_parameter_chk()
            {
                l_running_parameter_value="$(sysctl "$l_parameter_name" | awk -F= '{print $2}' | xargs)" # Check running configuration
                if grep -Pq -- '\b'"$l_parameter_value"'\b' <<< "$l_running_parameter_value"; then
                    a_output+=(" - \"$l_parameter_name\" is correctly set to \"$l_running_parameter_value\" in the running configuration")
                else
                    a_output2+=(" - \"$l_parameter_name\" is incorrectly set to \"$l_running_parameter_value\" in the running configuration and should have a value of: \"$l_value_out\"")
                fi
                
                unset A_out; declare -A A_out # Check durable setting (files)
                while read -r l_out; do
                    if [ -n "$l_out" ]; then
                        if [[ $l_out =~ ^\s*# ]]; then
                            l_file="${l_out//# /}"
                        else
                            l_kpar="$(awk -F= '{print $1}' <<< "$l_out" | xargs)"
                            [ "$l_kpar" = "$l_parameter_name" ] && A_out+=(["$l_kpar"]="$l_file")
                        fi
                    fi
                done < <("$l_systemdsysctl" --cat-config | grep -Po '^\h*([^#\n\r]+|#\h*\/[^#\n\r\h]+\.conf\b)')
                
                if [ -n "$l_ufwscf" ]; then # Account for systems with UFW (Not covered by systemd-sysctl --cat-config)
                    l_kpar="$(grep -Po "^\h*$l_parameter_name\b" "$l_ufwscf" | xargs)"
                    l_kpar="${l_kpar//\//.}"
                    [ "$l_kpar" = "$l_parameter_name" ] && A_out+=(["$l_kpar"]="$l_ufwscf")
                fi
                
                if (( ${#A_out[@]} > 0 )); then # Assess output from files and generate output
                    while IFS="=" read -r l_fkpname l_file_parameter_value; do
                        l_fkpname="${l_fkpname// /}"; l_file_parameter_value="${l_file_parameter_value// /}"
                        if grep -Pq -- '\b'"$l_parameter_value"'\b' <<< "$l_file_parameter_value"; then
                            a_output+=(" - \"$l_parameter_name\" is correctly set to \"$l_file_parameter_value\" in \"$(printf '%s' "${A_out[@]}")\"")
                        else
                            a_output2+=(" - \"$l_parameter_name\" is incorrectly set to \"$l_file_parameter_value\" in \"$(printf '%s' "${A_out[@]}")\" and should have a value of: \"$l_value_out\"")
                        fi
                    done < <(grep -Po -- "^\h*$l_parameter_name\h*=\h*\H+" "${A_out[@]}")
                else
                    a_output2+=(" - \"$l_parameter_name\" is not set in an included file" \
                        " ** Note: \"$l_parameter_name\" May be set in a file that's ignored by load procedure **")
                fi
            }
            
            l_systemdsysctl="$(readlink -f /lib/systemd/systemd-sysctl)"
            while IFS="=" read -r l_parameter_name l_parameter_value; do # Assess and check parameters
                l_parameter_name="${l_parameter_name// /}"; l_parameter_value="${l_parameter_value// /}"
                l_value_out="${l_parameter_value//-/ through }"; l_value_out="${l_value_out//|/ or }"
                l_value_out="$(tr -d '(){}' <<< "$l_value_out")"
                f_kernel_parameter_chk
            done < <(printf '%s\n' "${a_parlist[@]}")
            
            if [ "${#a_output2[@]}" -le 0 ]; then
                printf '%s\n' "" "- Audit Result:" " ** PASS **" "${a_output[@]}" ""
                exit 0
            else
                printf '%s\n' "" "- Audit Result:" " ** FAIL **" " - Reason(s) for audit failure:" "${a_output2[@]}"
                [ "${#a_output[@]}" -gt 0 ] && printf '%s\n' "" "- Correctly set:" "${a_output[@]}" ""
                exit 1
            fi
        }
      register: audit_1_5_1
      failed_when: false
      changed_when: false
      check_mode: false

    - name: "[3/3] Remediate 1.5.1: address space layout randomization is enabled"
      shell: |
        # 1.5.1 Ensure address space layout randomization is enabled (Automated)
        # Remediation: Set kernel.randomize_va_space = 2 in sysctl configuration
        # Description: ASLR is an exploit mitigation technique which randomly arranges 
        # the address space of key data areas of a process.
        SYSCTL_CONF="/etc/sysctl.d/60-kernel_sysctl.conf"
        PARAM_NAME="kernel.randomize_va_space"
        PARAM_VALUE="2"
        echo "Setting $PARAM_NAME = $PARAM_VALUE"
        # Check current running value
        echo "1. Current running configuration:"
        CURRENT_VALUE=$(sysctl -n "$PARAM_NAME" 2>/dev/null)
        echo "   $PARAM_NAME = $CURRENT_VALUE"
        # Set the parameter in configuration file
        echo "2. Setting durable configuration in $SYSCTL_CONF..."
        # Create the file if it doesn't exist, or update if it does
        if [ -f "$SYSCTL_CONF" ]; then
            # Check if the parameter already exists in the file
            if grep -q "^$PARAM_NAME" "$SYSCTL_CONF"; then
                # Update existing parameter
                sed -i "s/^$PARAM_NAME.*/$PARAM_NAME = $PARAM_VALUE/" "$SYSCTL_CONF"
                echo "   [OK] Updated existing parameter in $SYSCTL_CONF"
            else
                # Append the parameter
                printf "%s\n" "$PARAM_NAME = $PARAM_VALUE" >> "$SYSCTL_CONF"
                echo "   [OK] Added parameter to $SYSCTL_CONF"
            fi
        else
            # Create new file with the parameter
            printf "%s\n" "$PARAM_NAME = $PARAM_VALUE" >> "$SYSCTL_CONF"
            echo "   [OK] Created $SYSCTL_CONF with parameter"
        fi
        # Apply the setting to the running kernel
        echo "3. Applying to running kernel..."
        sysctl -w "$PARAM_NAME=$PARAM_VALUE"
        if [ $? -eq 0 ]; then
            echo "   [OK] Applied successfully"
        else
            echo "   [ERROR] Failed to apply kernel parameter"
            exit 1
        fi
        # Verify
        echo "4. Verification:"
        NEW_VALUE=$(sysctl -n "$PARAM_NAME" 2>/dev/null)
        echo "   $PARAM_NAME = $NEW_VALUE"
        if [ "$NEW_VALUE" = "$PARAM_VALUE" ]; then
            echo "[SUCCESS] ASLR is now enabled with value $PARAM_VALUE"
        else
            echo "[ERROR] Failed to set ASLR value"
            exit 1
        fi
      when: audit_1_5_1.rc == 1 and cis_apply_remediation | bool
      register: remediate_1_5_1
      ignore_errors: true

    - name: "[3/3] Display result for 1.5.1"
      debug:
        msg: |
          Rule 1.5.1: {{ "PASS" if audit_1_5_1.rc == 0 else "N/A" if audit_1_5_1.rc == 2 else "FIXED" if remediate_1_5_1 is defined and remediate_1_5_1.changed else "FAIL" }}

  post_tasks:
    - name: Display completion message
      debug:
        msg: "CIS hardening completed for 3 rules"
